'use strict';

var passportUtils = require('../passport/utils');
var loggerUtils = require('../utils/logger');
var tracer = loggerUtils.getTracer(__filename);

module.exports = function processConnectivity(req, res, next) {

  if (!req.internalUrl || !req.session ||
    !req.internalUrl.destination || (req.internalUrl.destination.proxyType !== 'OnPremise')) {
    return next();
  }

  var memoryStore = req.app.get('memoryStore');

  memoryStore.getSessionTimeout(req.session.id, function (err, sessionTimeout) {
    if (err) {
      return next(err);
    }
    if (req.session.connProxyToken &&
      (Date.now() + toMilliseconds(sessionTimeout) < req.session.connProxyToken.expiryDate - toMilliseconds(5))) {
      return next();
    }

    memoryStore.update(req.session.id, function (newSession) {
      var tokenRetrievalTimestamp =
        newSession.connProxyToken ? newSession.connProxyToken.expiryDate - toMilliseconds(5) : Date.now();
      if (newSession && (newSession.proxyTokenRetrievalStarted ||
        (newSession.connProxyToken && tokenRetrievalTimestamp > Date.now()))) {
        return next();
      }
      tracer.info('Retrieving Proxy Token started for session %s.', newSession.id);
      newSession.proxyTokenRetrievalStarted = true;
      var msBeforeRetrieval = tokenRetrievalTimestamp - Date.now() < 0 ? 0 : tokenRetrievalTimestamp - Date.now();
      executeAfter(function () {
        if (!newSession.connProxyToken || (newSession.connProxyToken && newSession.connProxyToken.expiryDate < Date.now())) {
          doGetProxyToken(req, newSession, next);
        }
        else {
          doGetProxyToken(req, newSession);
        }
      }, msBeforeRetrieval);
    }, false);
    if (req.session.connProxyToken && req.session.connProxyToken.expiryDate > Date.now()) {
      next();
    }
  });
};

function doGetProxyToken (req, session, next) {
  var credentials = req.routerConfig.appConfig.connectivity;
  req.internalUrl.destination.proxyHost = credentials.onpremise_proxy_host;
  req.internalUrl.destination.proxyPort = credentials.onpremise_proxy_port;
  var requestOptions = {
    url: credentials.url + '/oauth/token/?grant_type=client_credentials',
    headers: {
      'content-type': 'application/x-www-form-urlencoded;charset=utf-8',
      'accept': 'application/json;charset=utf-8'
    },
    auth: {
      user: credentials.clientid,
      pass: credentials.clientsecret
    }
  };

  passportUtils.callUaa(requestOptions, null, function (err, uaaResponse) {
    if (err) {
      return tracer.error('Error getting Proxy Token from UAA. Number of attempts done: %d, error: %s',
        passportUtils.MAX_ATTEMPTS_NUMBER, err.message);
    }

    if (!uaaResponse.access_token || !uaaResponse.expires_in) {
      return tracer.error ('Bad response from UAA when getting Proxy Token - not all fields are present');
    }

    req.app.get('memoryStore').update(session.id, function updateSession(newSession) {
      var options = {
        accessToken: uaaResponse.access_token,
        expiryDate: passportUtils.getExpiresAt(uaaResponse.expires_in).getTime()
      };
      newSession.connProxyToken = options;
      newSession.proxyTokenRetrievalStarted = false;
      if (next) {
        setTimeout(next, 0);
      }
    }, false);
  });
}

function executeAfter (fn, timeout) {
  setTimeout(fn, timeout);
}

function toMilliseconds(minutes) {
  return minutes * 60 * 1000;
}
